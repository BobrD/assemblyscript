/**
 * Bundled library components for in-browser usage.
 * @module assemblyscript/library
 */

/** AssemblyScript version. */
export const version: string = "0.4.0";

/** Library sources for in-browser usage. */
export const files: { [key: string]: string } = {
  "assembly.d.ts": "/**\n * TypeScript definition file for AssemblyScript compilation.\n * see: https://github.com/dcodeIO/AssemblyScript for details\n *\n * @module assembly\n */\n\n// Core types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = any; // as required for logical '&&' / '||'\n/** A 32-bit unsigned integer when targeting WASM32 respectively a 64-bit unsigned integer when targeting WASM64. */\ndeclare type usize = number;\n\n// Core type aliases\n\n/** An 8-bit signed integer. Alias of `i8`. */\ndeclare type sbyte = i8;\n/** An 8-bit unsigned integer. Alias of `u8`. */\ndeclare type byte = u8;\n/** A 16-bit signed integer. Alias of `i16`. */\ndeclare type short = i16;\n/** A 16-bit unsigned integer. Alias of `u16`. */\ndeclare type ushort = u16;\n/** A 32-bit signed integer. Alias of `i32`. */\ndeclare type int = i32;\n/** A 32-bit signed integer. Alias of `u32`. */\ndeclare type uint = u32;\n/** A 64-bit signed integer. Alias of `i64`. */\ndeclare type long = i64;\n/** A 64-bit unsigned integer. Alias of `u64`. */\ndeclare type ulong = u64;\n/** A 32-bit float. Alias of `f32`. */\ndeclare type float = f32;\n/** A 64-bit float. Alias of `f64`. */\ndeclare type double = f64;\n/** A 32-bit unsigned integer when targeting WASM32 respectively a 64-bit unsigned integer when targeting WASM64. Alias of `usize`. */\ndeclare type uintptr = usize;\n\n/** An 8-bit signed integer. Alias of `i8`. */\ndeclare type int8 = i8;\n/** An 8-bit unsigned integer. Alias of `u8`. */\ndeclare type uint8 = u8;\n/** A 16-bit signed integer. Alias of `i16`. */\ndeclare type int16 = i16;\n/** A 16-bit unsigned integer. Alias of `u16`. */\ndeclare type uint16 = u16;\n/** A 32-bit signed integer. Alias of `i32`. */\ndeclare type int32 = i32;\n/** A 32-bit signed integer. Alias of `u32`. */\ndeclare type uint32 = u32;\n/** A 64-bit signed integer. Alias of `i64`. */\ndeclare type int64 = i64;\n/** A 64-bit unsigned integer. Alias of `u64`. */\ndeclare type uint64 = u64;\n/** A 32-bit float. Alias of `f32`. */\ndeclare type float32 = f32;\n/** A 64-bit float. Alias of `f64`. */\ndeclare type float64 = f64;\n\n// Globals\n\n/** NaN (not a number) as a 64-bit float. */\ndeclare const NaN: f64;\n/** NaN (not a number) as a 32-bit float. */\ndeclare const NaNf: f32;\n/** Positive infinity as a 64-bit float. */\ndeclare const Infinity: f64;\n/** Positive infinity as a 32-bit float. */\ndeclare const Infinityf: f32;\n\n// Arrays\n\n/** A fixed-size array. */\ndeclare class Array<T> implements IDisposable {\n  /** Maximum number of elements this array can hold without resizing. */\n  readonly capacity: i32;\n  /** Number of elements this array currently holds. */\n  length: i32;\n\n  /** Constructs a new array with the specified number of elements. */\n  constructor(arrayLength: i32);\n\n  /** Returns the first index at which a given element can be found in the array, or `-1` if it is not present. The array is searched forward, starting at `fromIndex`. */\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  /** Returns the last index at which a given element can be found in the array, or `-1` if it is not present. The array is searched backwards, starting at `fromIndex`. */\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  /** Creates a shallow copy of a portion of the array as a new array object selected from `begin` to `end` (`end` not included). The original array will not be modified. */\n  slice(begin?: i32, end?: i32): this;\n  /** Reverses the array's elements in place. The first array element becomes the last, and the last array element becomes the first. */\n  reverse(): this;\n  dispose(): void;\n}\n\n/** A fixed-size 8-bit signed integer array. */\ndeclare class Int8Array extends Array<i8> {}\n/** A fixed-size 8-bit unsigned integer array. */\ndeclare class Uint8Array extends Array<u8> {}\n/** A fixed-size 16-bit signed integer array. */\ndeclare class Int16Array extends Array<i16> {}\n/** A fixed-size 16-bit unsigned integer array. */\ndeclare class Uint16Array extends Array<u16> {}\n/** A fixed-size 32-bit signed integer array. */\ndeclare class Int32Array extends Array<i32> {}\n/** A fixed-size 32-bit unsigned integer array. */\ndeclare class Uint32Array extends Array<u32> {}\n/** A fixed-size 64-bit signed integer array. */\ndeclare class Int64Array extends Array<i64> {}\n/** A fixed-size 64-bit unsigned integer array. */\ndeclare class Uint64Array extends Array<u64> {}\n/** A fixed-size 32-bit float array. */\ndeclare class Float32Array extends Array<f32> {}\n/** A fixed-size 64-bit float array. */\ndeclare class Float64Array extends Array<f64> {}\n\n// Strings\n\n/** A fixed-size UTF-16LE encoded string. */\ndeclare class String extends Array<u16> {\n  /** Constructs a new string with the specified number of characters. */\n  constructor(size: i32);\n\n  /** Returns the index within the string of the first occurrence of the specified value or `-1` if the value is not found. */\n  indexOfString(value: string): i32;\n  /** Determines whether the string begins with the specified value. */\n  startsWith(value: string): bool;\n  /** Determines whether the string ends with the specified value. */\n  endsWith(value: string): bool;\n}\n\n// Errors\n\n/** An error. */\ndeclare class Error {\n  /** Error message. */\n  message: string;\n  /** Constructs a new error with the specified message. */\n  constructor(message: string);\n}\n\n// Console\n\n/** Imported log interface. */\ndeclare function log(type: i32, message: string): void;\n\n/** Console bindings. */\ndeclare class console {\n  /** Logs a message to console. */\n  static log(message: string): void;\n  /** Logs an informative message to console. */\n  static info(message: string): void;\n  /** Logs a warning message to console. */\n  static warn(message: string): void;\n  /** Logs an error message to console. */\n  static error(message: string): void;\n}\n\n// Builtins\n\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\ndeclare function rotl(value: i32, shift: i32): i32;\n/** Performs the sign-agnostic rotate left operation on a 64-bit integer. */\ndeclare function rotll(value: i64, shift: i64): i64;\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\ndeclare function rotr(value: i32, shift: i32): i32;\n/** Performs the sign-agnostic rotate right operation on a 64-bit integer. */\ndeclare function rotrl(value: i64, shift: i64): i64;\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz(value: i32): i32;\n/** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clzl(value: i64): i64;\n/** Performs the sign-agnostic count trailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz(value: i32): i32;\n/** Performs the sign-agnostic count trailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctzl(value: i64): i64;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\ndeclare function popcnt(value: i32): i32;\n/** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */\ndeclare function popcntl(value: i64): i64;\n/** Computes the absolute value of a 64-bit float. */\ndeclare function abs(value: f64): f64;\n/** Computes the absolute value of a 32-bit float. */\ndeclare function absf(value: f32): f32;\n/** Performs the ceiling operatoion on a 64-bit float. */\ndeclare function ceil(value: f64): f64;\n/** Performs the ceiling operation on a 32-bit float. */\ndeclare function ceilf(value: f32): f32;\n/** Performs the floor operation on a 64-bit float. */\ndeclare function floor(value: f64): f64;\n/** Performs the floor operation on a 32-bit float. */\ndeclare function floorf(value: f32): f32;\n/** Calculates the square root of a 64-bit float. */\ndeclare function sqrt(value: f64): f64;\n/** Calculates the square root of a 32-bit float. */\ndeclare function sqrtf(value: f32): f32;\n/** Rounds to nearest integer towards zero of a 64-bit float. */\ndeclare function trunc(value: f64): f64;\n/** Rounds to nearest integer towards zero of a 32-bit float. */\ndeclare function truncf(value: f32): f32;\n/** Rounds to nearest integer tied to even of a 64-bit float. */\ndeclare function nearest(value: f64): f64;\n/** Rounds to nearest integer tied to even of a 32-bit float. */\ndeclare function nearestf(value: f32): f32;\n/** Determines the minimum of two 64-bit floats. If either operand is NaN, returns NaN. */\ndeclare function min(left: f64, right: f64): f64;\n/** Determines the minimum of two 32-bit floats. If either operand is NaN, returns NaN. */\ndeclare function minf(left: f32, right: f32): f32;\n/** Determines the maximum of two 64-bit floats. If either operand is NaN, returns NaN. */\ndeclare function max(left: f64, right: f64): f64;\n/** Determines the maximum of two 32-bit floats. If either operand is NaN, returns NaN. */\ndeclare function maxf(left: f32, right: f32): f32;\n/** Composes a 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign(x: f64, y: f64): f64;\n/** Composes a 32-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysignf(x: f32, y: f32): f32;\n/** Reinterprets the bits of a 32-bit float as a 32-bit integer. */\ndeclare function reinterpreti(value: f32): i32;\n/** Reinterprets the bits of a 64-bit float as a 64-bit integer. */\ndeclare function reinterpretl(value: f64): i64;\n/** Reinterprets the bits of a 32-bit integer as a 32-bit float. */\ndeclare function reinterpretf(value: i32): f32;\n/** Reinterprets the bits of a 64-bit integer as a 64-bit double. */\ndeclare function reinterpretd(value: i64): f64;\n/** Returns the current memory size in units of pages. One page is 64kb. */\ndeclare function current_memory(): i32;\n/** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\ndeclare function grow_memory(value: i32): i32;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): void;\n\n/** Determines the byte size of the specified core or class type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Loads a value of the specified type from memory. */\ndeclare function load<T>(offset: usize): T;\n/** Stores a value of the specified type to memory. */\ndeclare function store<T>(offset: usize, value: T): void;\n/** Casts a value of type `T1` to a value of type `T2`. Useful for casting classes to pointers and vice-versa. Does not perform any checks. */\ndeclare function unsafe_cast<T1,T2>(value: T1): T2;\n/** Tests if a 64-bit float is a NaN. */\ndeclare function isNaN(value: f64): bool;\n/** Tests if a 32-bit float is a NaN. */\ndeclare function isNaNf(value: f32): bool;\n/** Tests if a 64-bit float is finite. */\ndeclare function isFinite(value: f64): bool;\n/** Tests if a 32-bit float is finite. */\ndeclare function isFinitef(value: f32): bool;\n\n// Core runtime\n\n/** Sets a chunk of memory to the provided value `c`. Usually used to reset it to all `0`s. */\ndeclare function memset(dest: usize, c: i32, size: usize): usize;\n/** Copies data from one chunk of memory to another. */\ndeclare function memcpy(dest: usize, src: usize, size: usize): usize;\n/** Compares a chunk of memory to another. Returns `0` if both are equal, otherwise the difference `vl[i] - vr[i]` of the first differing byte values. */\ndeclare function memcmp(left: usize, right: usize, size: usize): i32;\n/** Allocates a chunk of memory of the specified size. */\ndeclare function malloc(size: usize): usize;\n/** Changes the size of an allocated memory block. */\ndeclare function realloc(ptr: usize, size: usize): usize;\n/** Frees a previously allocated chunk of memory. */\ndeclare function free(ptr: usize): void;\n\n// Experimental garbage collector runtime\n\n/** Pauses automatic garbage collection. */\ndeclare function gc_pause(): void;\n/** Resumes automatic garbage collection. */\ndeclare function gc_resume(): void;\n/** Runs the garbage collector. */\ndeclare function gc_collect(): void;\n/** Allocates a garbage collector controlled chunk of memory of the specified size. */\ndeclare function gc_alloc(size: usize, flags: i32): usize;\n/** Changes the size of a garbage collector controlled memory block. */\ndeclare function gc_realloc(ptr: usize, size: usize): usize;\n/** Retains a gargabe collector controlled memory block. */\ndeclare function gc_retain(ptr: usize): usize;\n/** Releases a garbage collector controlled memory block previously retained. */\ndeclare function gc_release(ptr: usize): usize;\n\n// Temporary fillers\n\n/** @private */ declare interface Boolean {}\n/** @private */ declare interface Function {}\n/** @private */ declare interface IArguments {}\n/** @private */ declare interface Number {}\n/** @private */ declare interface Object {}\n/** @private */ declare interface RegExp {}\n/** @private */ declare interface Symbol {}\n\n// Interfaces\n\n/** Marks a class as being disposable (can be free'd from memory manually). */\ndeclare interface IDisposable {\n  /** Releases this instance's memory by calling `free`. The instance or a reference to it must not be used anymore afterwards. */\n  dispose(): void;\n}\n\n// Internal decorators\ndeclare function no_implicit_malloc();\n",
  "std/array.ts": "export class Array<T> implements IDisposable {\n  readonly capacity: i32; // @0 (4)\n  length: i32;            // @4 (4)\n  readonly base: usize;   // @8 (4/8)\n\n  constructor(capacity: i32) {\n    if (capacity < 0)\n      throw new Error(\"Invalid array length\");\n    this.length = this.capacity = capacity;\n    const dataSize: usize = this.capacity as usize * sizeof<T>();\n    this.base = memset(malloc(dataSize), 0, dataSize);\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    let length: i32 = this.length;\n    if (length > this.capacity)\n      length = this.capacity;\n\n    // if negative, it is taken as the offset from the end of the array\n    if (fromIndex < 0) {\n      fromIndex = length + fromIndex;\n\n      // if the calculated index is less than 0, then the whole array will be searched\n      if (fromIndex < 0)\n        fromIndex = 0;\n    }\n\n    // implicit: if greater than or equal to the array's length, -1 is returned\n    while (fromIndex < length) {\n      if (this[fromIndex] == searchElement)\n        return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = 0x7fffffff): i32 {\n    let length: i32 = this.length;\n    if (length > this.capacity)\n      length = this.capacity;\n\n     // if negative, it is taken as the offset from the end of the array\n    if (fromIndex < 0)\n      fromIndex = length + fromIndex;\n\n    // if greater than or equal to the length of the array, the whole array will be searched\n    else if (fromIndex >= length)\n      fromIndex = length - 1;\n\n    // implicit: if the calculated index is less than 0, -1 is returned\n    while (fromIndex >= 0) {\n      if (this[fromIndex] == searchElement)\n        return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  slice(begin: i32 = 0, end: i32 = 0x7fffffff): this {\n    let length: i32 = this.length;\n    if (length > this.capacity)\n      length = this.capacity;\n\n    if (begin < 0) {\n      begin = length + begin;\n      if (begin < 0)\n        begin = 0;\n    } else if (begin > length)\n      begin = length;\n\n    if (end < 0)\n      end = length + end;\n    else if (end > length)\n      end = length;\n\n    if (end < begin)\n      end = begin;\n\n    const capacity: i32 = end - begin;\n    const dataSize: usize = (capacity as usize) * sizeof<T>();\n\n    const slice: usize = malloc(sizeof<Array<T>>());\n    store<i32>(slice, capacity);\n    store<i32>(slice + 4, capacity);\n    store<usize>(slice + 8, this.base + begin * sizeof<T>());\n    return unsafe_cast<usize,this>(slice);\n  }\n\n  reverse(): this {\n    let length: int = this.length;\n    if (length > this.capacity)\n      length = this.capacity;\n\n    // transposes the elements of the calling array object in place, mutating the array\n    for (let i: int = 0, j: int = length - 1, t: int; i < j; ++i, --j) {\n      t = this[i];\n      this[i] = this[j];\n      this[j] = t;\n    }\n\n    // and returning a reference to the array\n    return this;\n  }\n\n  dispose(disposeData: bool = true): void {\n    free(unsafe_cast<this,usize>(this));\n    if (disposeData)\n      free(this.base);\n  }\n}\n",
  "std/string.ts": "export class String extends Array<ushort> {\n\n  indexOfString(value: string): int { // FIXME: any way to overload this?\n    if (value.length > this.length)\n      return -1;\n    const thisPtr: usize = unsafe_cast<String,usize>(this) + sizeof<Array<ushort>>();\n    const valuePtr: usize = unsafe_cast<string,usize>(value) + sizeof<Array<ushort>>();\n    const limitPtr: usize = this.length - value.length;\n    for (let offsetPtr: usize = 0; offsetPtr < limitPtr; offsetPtr += sizeof<ushort>())\n      if (memcmp(thisPtr + offsetPtr, valuePtr, value.length) == 0)\n        return offsetPtr as int;\n    return -1;\n  }\n\n  startsWith(value: string): bool {\n    if (value.length > this.length)\n      return false;\n    const thisPtr: usize = unsafe_cast<String,usize>(this) + sizeof<Array<ushort>>();\n    const valuePtr: usize = unsafe_cast<string,usize>(value) + sizeof<Array<ushort>>();\n    return memcmp(thisPtr, valuePtr, value.length << 1) == 0;\n  }\n\n  endsWith(value: string): bool {\n    if (value.length > this.length)\n      return false;\n    const thisPtr: usize = unsafe_cast<String,usize>(this) + sizeof<Array<ushort>>();\n    const valuePtr: usize = unsafe_cast<string,usize>(value) + sizeof<Array<ushort>>();\n    return memcmp(thisPtr + ((this.length - value.length) << 1) as usize, valuePtr, value.length) == 0;\n  }\n}\n",
  "std/console.ts": "enum LogType {\n  Log = 0,\n  Info = 1,\n  Warn = 2,\n  Error = 3\n}\n\nexport class console {\n\n  static log(message: string): void {\n    log(LogType.Log, message);\n  }\n\n  static info(message: string): void {\n    log(LogType.Info, message);\n  }\n\n  static warn(message: string): void {\n    log(LogType.Warn, message);\n  }\n\n  static error(message: string): void {\n    log(LogType.Error, message);\n  }\n}"
};

/** Precompiled memory management runtime as a base64-encoded string. */
export const runtime: string = "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EHQgB0EQdnI2AgAgA0EQaiEDIAhBcGohCAwACwALIAEgCkFuIApBbksbIA5qQXBxIgVqIARqQQJqIQNBfiAFayACaiAEayENCyANQRBxBEAgCyADKQAANwAAIAsgAykACDcACCALQRBqIQsgA0EQaiEDCyANQQhxBEAgCyADKQAANwAAIAtBCGohCyADQQhqIQMLIA1BBHEEQCALIAMoAAA2AAAgC0EEaiELIANBBGohAwsgDUECcQRAIAsgAy8AADsAACALQQJqIQsgA0ECaiEDCyANQQFxRQ0AIAsgAy0AADoAACAADwsgAAsL/4KAgAACAn8BfgJ/AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiABOgAAIAAgAToAAyACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCECADIAE2AgwgAyABNgIUIAMgATYCGCACQWhqIAE2AgAgAkFkaiABNgIAIAJBbGogATYCACACQXBqIAE2AgAgAa0iBUIghiAFhCEFIAQgA0EEcUEYciIBayECIAMgAWohAQNAIAJBIEkNASABIAU3AwAgAUEIaiAFNwMAIAFBEGogBTcDACABQRhqIAU3AwAgAUEgaiEBIAJBYGohAgwACwALIAALC8qAgIAAAQF/AkBBDCgCAARADwtBBCgCAEEQayEAQRBCgICEgICAwAA3AgBBGEJ/NwIAQQwgAEEMakFwcUHYqtWqBXM2AgBBIEEANgIACwvyrICAAAEJfwJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQfQBTQRAIAAoAgAiBEEQIAFBC2pBeHEgAUELSRsiBUEDdiICdiIBQQNxRQ0BIAAgAUF/c0EBcSACaiICQQN0aiIDQTBqKAIAIgFBCGohBiABKAIIIgUgA0EoaiIDRg0CIAUgAzYC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";
